\import Arith.Nat
\import Data.Bool
\import Function.Meta
\import Logic
\import Paths.Meta
\open Nat

\class Category (Ob : \Type) {
  | Hom : \Pi (source target : Ob) -> \Set
  | comp \alias \infixr 8 ∘ : \Pi {x y z : Ob} (g : Hom y z) (f : Hom x y) -> Hom x z
  | id : \Pi {x : Ob} -> Hom x x

  | comp-id-left : \Pi {x y : Ob} {f : Hom x y} -> id ∘ f = f
  | comp-id-right : \Pi {x y : Ob} {f : Hom x y} -> f ∘ id = f
  | comp-assoc : \Pi {x y z w : Ob} {f : Hom x y} {g : Hom y z} {h : Hom z w} -> h ∘ (g ∘ f) = (h ∘ g) ∘ f
}

\class Preorder' (A : \Type) {
  | \infix 4 <== : A -> A -> \Prop
  | leq-refl : \Pi {x : A} -> x <== x
  | leq-trans : \Pi {x y z : A} -> x <== y -> y <== z -> x <== z
}

\instance NatLE' : Preorder' Nat
  | <== => <=
  | leq-refl => NatLE.<=-reflexive
  | leq-trans => NatLE.<=-transitive

\func and-false (x : Bool) : x and false = false
  | false => idp
  | true  => idp

\func and-true (x : Bool) : x and true = x
  | false => idp
  | true  => idp

\func preorder-is-category {A : \Type} (pr : Preorder' A) : Category A \cowith
  | Hom => \lam source target => Bool
  | comp => and
  | id => true
  | comp-id-left => idp
  | comp-id-right {x} {y} {f} => \case f \as g, idp : g = f \with {
    | false, q => rewriteI q idp
    | true , q => rewriteI q idp
  }
  | comp-assoc {x} {y} {z} {w} {f} {g} {h} => \case f \as f', idp : f' = f \with {
    | false, p => rewriteI p $ rewrite and-false $ rewrite and-false $ rewrite and-false idp
    | true , p => rewriteI p $ rewrite and-true $ rewrite and-true idp
  }

\instance NatLECat : Category Nat => preorder-is-category NatLE'

\class Functor (C D : Category) (\classifying F0 : C.Ob -> D.Ob) {
  | F1 {x y : C.Ob} (Hom x y) : Hom (F0 x) (F0 y)

  | id-proof {x : C.Ob} : F1 (C.id {x}) = D.id {F0 x}
  | comp-proof {x y z : C.Ob} {f : C.Hom x y} {g : C.Hom y z} : F1 (g ∘ f) = F1 g ∘ F1 f
}

\data Option (T : \Type)
  | Some T
  | None

\data Unit
  | I

\instance ConstCat : Category Unit
  | Hom => \lam _ _ => Unit
  | comp => \lam _ _ => I
  | id => I
  | comp-id-left {x} {y} {f} => \case f \as g, idp : g = f \with {
    | I, q => rewriteI q idp
  }
  | comp-id-right {x} {y} {f} => \case f \as g, idp : g = f \with {
    | I, q => rewriteI q idp
  }
  | comp-assoc {x} {y} {z} {w} {f} {g} {h} => \case f \as f', idp : f' = f \with {
    | I, p => rewrite p idp
  }

\func Id {C : Category} : Functor C C \cowith
  | F0 x => x
  | F1 h => h
  | comp-proof => idp
  | id-proof => idp

\data State (S A : \Set)
  | state (S -> \Sigma S A)

\record State' (S A : \Set)
  | runState : S -> \Sigma S A

-- \lam a => f a === f
-- (p.1,p.2) === p

\record R
  | a : Nat
  | b : Nat

\data Pair (A : \Type)
  | pair A A

-- \new R p.a p.b === p

\func IdFunctor (C : Category) : Functor C C \cowith
  | F0 x => x
  | F1 {x} {y} h => h
  | comp-proof => {?}
  | id-proof => {?}

\func StateFunctor (C : Category) : Functor C C \cowith
  | F0 x => x
  | F1 {x} {y} h => h
  | comp-proof => {?}
  | id-proof => {?}

--\instance UnitFunctor : Functor ConstCat ConstCat
--  | F0 x => x
--  | F1 {x} {y} h => {?}
--  | comp-proof => {?}
--  | id-proof => {?}

--\instance UnitFunctor' (C : Category) : Functor C ConstCat
--  | F0 _ => I
--  | F1 {x} {y} h => h
--  | comp-proof => {?}
--  | id-proof => {?}
