\import Arith.Nat
\import Data.Bool
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths.Meta
\import Paths
\open Nat

\class Category (Ob : \Type) {
  | Hom : \Pi (source target : Ob) -> \Set
  | comp \alias \infixr 8 ∘ : \Pi {x y z : Ob} (g : Hom y z) (f : Hom x y) -> Hom x z
  | id : \Pi {x : Ob} -> Hom x x

  | comp-id-left : \Pi {x y : Ob} {f : Hom x y} -> id ∘ f = f
  | comp-id-right : \Pi {x y : Ob} {f : Hom x y} -> f ∘ id = f
  | comp-assoc : \Pi {x y z w : Ob} {f : Hom x y} {g : Hom y z} {h : Hom z w} -> h ∘ (g ∘ f) = (h ∘ g) ∘ f
}

\func Op (C : Category) : Category \cowith
  | Ob => C.Ob
  | Hom => \lam source target => C.Hom target source
  | comp => \lam g f => f ∘ g
  | id => C.id
  | comp-id-left => C.comp-id-right
  | comp-id-right => C.comp-id-left
  | comp-assoc => inv C.comp-assoc

\class Preorder' (A : \Type) {
  | \infix 4 <== : A -> A -> \Prop
  | leq-refl : \Pi {x : A} -> x <== x
  | leq-trans : \Pi {x y z : A} -> x <== y -> y <== z -> x <== z
}

\instance NatLE' : Preorder' Nat
  | <== => <=
  | leq-refl => NatLE.<=-reflexive
  | leq-trans => NatLE.<=-transitive

\func and-false (x : Bool) : x and false = false
  | false => idp
  | true  => idp

\func and-true (x : Bool) : x and true = x
  | false => idp
  | true  => idp

\func preorder-is-category {A : \Type} (pr : Preorder' A) : Category A \cowith
  | Hom => \lam source target => Bool
  | comp => and
  | id => true
  | comp-id-left => idp
  | comp-id-right {x} {y} {f} => \case f \as g, idp : g = f \with {
    | false, q => rewriteI q idp
    | true , q => rewriteI q idp
  }
  | comp-assoc {x} {y} {z} {w} {f} {g} {h} => \case f \as f', idp : f' = f \with {
    | false, p => rewriteI p $ rewrite and-false $ rewrite and-false $ rewrite and-false idp
    | true , p => rewriteI p $ rewrite and-true $ rewrite and-true idp
  }

\instance NatLECat : Category Nat => preorder-is-category NatLE'

\class Functor (C D : Category) {
  | \classifying omap : C.Ob -> D.Ob
  | fmap {x y : C.Ob} (Hom x y) : Hom (omap x) (omap y)

  | id-proof {x : C.Ob} : fmap (C.id {x}) = D.id {omap x}
  | comp-proof {x y z : C.Ob} {f : C.Hom x y} {g : C.Hom y z} : fmap (g ∘ f) = fmap g ∘ fmap f
}

\data Unit
  | I

\instance EmptyCat : Category Empty
  | Hom => \lam source _ => absurd source
  | comp => \lam g f => f
  | id => contradiction
  | comp-id-left => idp
  | comp-id-right => contradiction
  | comp-assoc => idp

\instance UnitCat : Category Unit
  | Hom => \lam _ _ => Unit
  | comp => \lam _ _ => I
  | id => I
  | comp-id-left {x} {y} {f} => \case f \as g, idp : g = f \with {
    | I, q => rewriteI q idp
  }
  | comp-id-right {x} {y} {f} => \case f \as g, idp : g = f \with {
    | I, q => rewriteI q idp
  }
  | comp-assoc {x} {y} {z} {w} {f} {g} {h} => \case f \as f', idp : f' = f \with {
    | I, p => rewrite p idp
  }

\func IdFunctor {C : Category} : Functor C C \cowith
  | omap x => x
  | fmap h => h
  | comp-proof => idp
  | id-proof => idp

\class NaturalTransformation {C D : Category} (F G : Functor C D) {
  | component : \Pi (x : C.Ob) -> Hom (F x) (G x)
  | naturality : \Pi (x y : C.Ob) (f : Hom x y) -> component y ∘ fmap f = fmap f ∘ component x
}

-- C = two parallel arrows between objects s t
-- construct [C; Set], it will be the same as graph

\instance FunctorCategory (C D : Category) : Category
  | Ob => Functor C D
  | Hom => NaturalTransformation
  | comp => \lam alpha beta => \new NaturalTransformation {
    | component  => \lam t => (component {alpha} t) ∘ (component {beta} t)
    | naturality => {?}
  }
  | id => \new NaturalTransformation {
    | component => \lam t => id
    | naturality => {?}
  }
  | comp-id-left => {?}
  | comp-id-right => {?}
  | comp-assoc => {?}

\instance SetCat : Category
  | Ob => \Set
  | Hom => \lam source target => source -> target
  | comp => \lam f g => \lam x => f $ g x
  | id => \lam x => x
  | comp-id-left => idp
  | comp-id-right => idp
  | comp-assoc => ext (\lam x => idp)

\func PreSheaf (C : Category) : Category
  => FunctorCategory (Op C) SetCat

\instance HomFunctor {C : Category} (x : C.Ob) : Functor C SetCat
  | omap => {?}
  | fmap => {?}
  | id-proof => {?}
  | comp-proof => {?}